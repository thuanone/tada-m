import React from 'react';

// 3rd-party
import * as logger from 'loglevel';
import * as logPrefixer from 'loglevel-plugin-prefix';
import * as logRemote from 'loglevel-plugin-remote';

import flagsApi from '../../api/flags';
import csrf from '../../utils/csrf';

const env = window.armada;
const config = env.config;

class ClgLoggingManager extends React.Component<{}, {}> {

  constructor(props) {
    super(props);

    this.setupLogger(logger);
  }

  public render() {
    return <React.Fragment />;
  }

  private setupLogger(loggerToSetup: any): void {
    // Enable the prefixer
    logPrefixer.reg(loggerToSetup);
    loggerToSetup.enableAll();
    logPrefixer.apply(loggerToSetup, {
      timestampFormatter(date) {
        return date.toISOString();
      },
      format(level, name, timestamp) {
        return `[${timestamp}] ${level} ${name}`;
      },
    });
    loggerToSetup.setDefaultLevel('INFO');
    loggerToSetup.setLevel('INFO');

    const featureFlags = `${flagsApi.flags.FEATURE_CLIENTERRORS},${flagsApi.flags.FEATURE_CLIENTLOGS}`;

    // check whether the features are enabled that sends all client side logs to the server
    flagsApi.getFlag(featureFlags, (flag) => {
      // console.info(`feature flags ${featureFlags} have been evaluated: '${JSON.stringify(flag)}'`);

      // check whether the client error should be send to the server
      if (!flag || !flag.value || !flag.value[flagsApi.flags.FEATURE_CLIENTERRORS]) {
        return;
      }

      // per default we only want to receive error logs on the server side
      let level = 'error';

      if (flag.value[flagsApi.flags.FEATURE_CLIENTLOGS]) {
        level = 'debug';

        // in order to retrieve all logs, we need to set the general log level to the same level
        loggerToSetup.setLevel('DEBUG');
      }

      // enable the remote plugin to send errors to the server
      logRemote.apply(loggerToSetup, {

        // the size of the queue in which messages are accumulated between sending
        capacity: 50,

        // we want to send our logs as JSON array
        format: (log) => {
          log.level = log.level.label;
          return log;
        },

        // the endpoint validates whether a proper CSRF token is present
        headers: {
          'csrf-token': csrf.getCsrfToken()
        },

        // in order to protect us for too much load, we have an interval >1000
        interval: 5000,

        // object for configuring a stacktrace
        stacktrace: {
          // number of stack trace lines
          depth: 3,
          // number of excess lines generated by following plugins
          excess: 0,
          // levels for which to add the stack trace
          levels: ['error'],
        },

        // specifies the log level that should be send to the server
        level, // error, debug

        // TODO we should think of using a feature flag that allows us to turn this flag to debug for certain users

        // in case the API endpoint does not respond properly, we need to timeout
        timeout: 4000,

        // this is the URL endpoint that all logs will be sent to
        url: `${config.proxyRoot}api/monitoring/v1/logger`,

      });
    });
  }
}

// @ts-ignore
ClgLoggingManager.propTypes = {};

export default ClgLoggingManager;
